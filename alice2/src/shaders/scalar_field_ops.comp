#version 430
// Fallback for older systems
// #version 330

// Compute shader for scalar field operations
// Designed to work with 100x100 scalar field grids used in educational sketches

// Local work group size - optimized for better GPU utilization
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// Shader storage buffer objects for input and output data
layout(std430, binding = 0) restrict buffer FieldABuffer {
    float fieldA[];  // Input A and Output (in-place operation)
};

layout(std430, binding = 1) restrict readonly buffer FieldBBuffer {
    float fieldB[];  // Input B
};

layout(std430, binding = 2) restrict buffer ResultBuffer {
    float result[];  // Same as fieldA for in-place operations
};

// Uniform parameters
uniform int gridWidth;
uniform int gridHeight;
uniform int operation; // 0=union, 1=intersect, 2=subtract, 3=smin

// Smooth minimum parameters (for smin operation)
uniform float smoothing;
uniform float weight;

// Boolean operation functions matching CPU implementation
float booleanUnion(float a, float b) {
    return min(a, b);
}

float booleanIntersect(float a, float b) {
    return max(a, b);
}

float booleanSubtract(float a, float b) {
    return max(a, -b);
}

// Smooth minimum function matching ScalarFieldUtils::smooth_min
float smoothMin(float a, float b, float k) {
    if (k <= 0.0) {
        return min(a, b);
    }
    
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * h * k * (1.0 / 6.0);
}

// Weighted smooth minimum function matching ScalarFieldUtils::smooth_min_weighted
float smoothMinWeighted(float a, float b, float k, float w) {
    if (k <= 0.0) {
        return mix(a, b, w);
    }
    
    float h = max(k - abs(a - b), 0.0) / k;
    float m = h * h * h * k * (1.0 / 6.0);
    return mix(a, b, w) - m;
}

void main() {
    // Get current thread's position in the grid
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    
    // Bounds check
    if (coord.x >= gridWidth || coord.y >= gridHeight) {
        return;
    }
    
    // Calculate linear index (matching ScalarField2D::get_index)
    int index = coord.y * gridWidth + coord.x;
    
    // Bounds check for buffer access
    if (index >= fieldA.length() || index >= fieldB.length() || index >= result.length()) {
        return;
    }
    
    // Get input values
    float valueA = fieldA[index];
    float valueB = fieldB[index];
    
    // Perform the requested operation
    float resultValue;
    
    switch (operation) {
        case 0: // Boolean Union
            resultValue = booleanUnion(valueA, valueB);
            break;
            
        case 1: // Boolean Intersect
            resultValue = booleanIntersect(valueA, valueB);
            break;
            
        case 2: // Boolean Subtract
            resultValue = booleanSubtract(valueA, valueB);
            break;
            
        case 3: // Smooth Min (smin)
            resultValue = smoothMin(valueA, valueB, smoothing);
            break;
            
        case 4: // Weighted Smooth Min
            resultValue = smoothMinWeighted(valueA, valueB, smoothing, weight);
            break;
            
        default:
            // Default to union operation
            resultValue = booleanUnion(valueA, valueB);
            break;
    }
    
    // Write result
    result[index] = resultValue;
}

// Additional compute shader for scalar field generation operations
// This can be used for generating basic shapes on GPU

/*
// Alternative entry point for field generation (would need separate shader)
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(std430, binding = 0) restrict writeonly buffer OutputBuffer {
    float output[];
};

uniform int gridWidth;
uniform int gridHeight;
uniform vec2 minBounds;
uniform vec2 maxBounds;
uniform int shapeType; // 0=circle, 1=rect, 2=line
uniform vec3 shapeParams; // center.xy + radius/size/thickness
uniform float shapeAngle;

void generateShape() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    
    if (coord.x >= gridWidth || coord.y >= gridHeight) {
        return;
    }
    
    int index = coord.y * gridWidth + coord.x;
    
    // Calculate world position
    vec2 span = maxBounds - minBounds;
    vec2 step = span / vec2(gridWidth - 1, gridHeight - 1);
    vec2 worldPos = minBounds + vec2(coord) * step;
    
    float sdf = 0.0;
    
    switch (shapeType) {
        case 0: // Circle SDF
            sdf = length(worldPos - shapeParams.xy) - shapeParams.z;
            break;
            
        case 1: // Rectangle SDF (simplified)
            vec2 d = abs(worldPos - shapeParams.xy) - vec2(shapeParams.z);
            sdf = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
            break;
            
        default:
            sdf = 1000.0; // Large positive value
            break;
    }
    
    output[index] = sdf;
}
*/
