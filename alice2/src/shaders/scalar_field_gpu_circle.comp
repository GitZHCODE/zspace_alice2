#version 430

// Apply scalar circle compute shader
// Generates signed distance field for a circle

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// Scalar field values buffer
layout(std430, binding = 0) restrict buffer FieldBuffer {
    float fieldValues[];
};

// Uniforms
uniform int gridWidth;
uniform int gridHeight;
uniform vec3 minBounds;
uniform vec3 maxBounds;
uniform vec3 circleCenter;
uniform float circleRadius;
uniform float strength;

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    
    // Check bounds
    if (coord.x >= gridWidth || coord.y >= gridHeight) {
        return;
    }
    
    // Calculate world position
    vec2 gridSize = vec2(gridWidth - 1, gridHeight - 1);
    vec2 t = vec2(coord) / gridSize;
    vec3 worldPos = mix(minBounds, maxBounds, vec3(t, 0.0));
    
    // Calculate distance to circle center
    vec2 diff = worldPos.xy - circleCenter.xy;
    float distance = length(diff);
    
    // Signed distance field: negative inside, positive outside
    float sdf = distance - circleRadius;
    
    // Apply strength multiplier
    sdf *= strength;
    
    // Calculate linear index and store result
    int index = coord.y * gridWidth + coord.x;
    fieldValues[index] = sdf;
}
